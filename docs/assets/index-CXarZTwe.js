import{_}from"./extends-CCbyfPlC.js";import{r as c}from"./index-DGAqIW1f.js";var P;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(P||(P={}));var z=function(e){return Object.freeze(e)};function F(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}var M="beforeunload",G="popstate";function se(e){e===void 0&&(e={});var t=e,n=t.window,a=n===void 0?document.defaultView:n,r=a.history;function u(){var o=a.location,i=o.pathname,h=o.search,y=o.hash,v=r.state||{};return[v.idx,z({pathname:i,search:h,hash:y,state:v.usr||null,key:v.key||"default"})]}var l=null;function s(){if(l)m.call(l),l=null;else{var o=P.Pop,i=u(),h=i[0],y=i[1];if(m.length)if(h!=null){var v=p-h;v&&(l={action:o,location:y,retry:function(){C(v*-1)}},C(v))}else F(!1,"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.");else T(o)}}a.addEventListener(G,s);var f=P.Pop,d=u(),p=d[0],g=d[1],x=U(),m=U();p==null&&(p=0,r.replaceState(_({},r.state,{idx:p}),""));function w(o){return typeof o=="string"?o:X(o)}function R(o,i){return i===void 0&&(i=null),z(_({pathname:g.pathname,hash:"",search:""},typeof o=="string"?E(o):o,{state:i,key:Q()}))}function H(o,i){return[{usr:o.state,key:o.key,idx:i},w(o)]}function j(o,i,h){return!m.length||(m.call({action:o,location:i,retry:h}),!1)}function T(o){f=o;var i=u();p=i[0],g=i[1],x.call({action:f,location:g})}function B(o,i){var h=P.Push,y=R(o,i);function v(){B(o,i)}if(j(h,y,v)){var b=H(y,p+1),W=b[0],k=b[1];try{r.pushState(W,"",k)}catch{a.location.assign(k)}T(h)}}function J(o,i){var h=P.Replace,y=R(o,i);function v(){J(o,i)}if(j(h,y,v)){var b=H(y,p),W=b[0],k=b[1];r.replaceState(W,"",k),T(h)}}function C(o){r.go(o)}var q={get action(){return f},get location(){return g},createHref:w,push:B,replace:J,go:C,back:function(){C(-1)},forward:function(){C(1)},listen:function(i){return x.push(i)},block:function(i){var h=m.push(i);return m.length===1&&a.addEventListener(M,Y),function(){h(),m.length||a.removeEventListener(M,Y)}}};return q}function Y(e){e.preventDefault(),e.returnValue=""}function U(){var e=[];return{get length(){return e.length},push:function(n){return e.push(n),function(){e=e.filter(function(a){return a!==n})}},call:function(n){e.forEach(function(a){return a&&a(n)})}}}function Q(){return Math.random().toString(36).substr(2,8)}function X(e){var t=e.pathname,n=t===void 0?"/":t,a=e.search,r=a===void 0?"":a,u=e.hash,l=u===void 0?"":u;return r&&r!=="?"&&(n+=r.charAt(0)==="?"?r:"?"+r),l&&l!=="#"&&(n+=l.charAt(0)==="#"?l:"#"+l),n}function E(e){var t={};if(e){var n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));var a=e.indexOf("?");a>=0&&(t.search=e.substr(a),e=e.substr(0,a)),e&&(t.pathname=e)}return t}/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */const S=c.createContext(null);S.displayName="Navigation";const L=c.createContext(null);L.displayName="Location";const $=c.createContext({outlet:null,matches:[]});$.displayName="Route";function N(e,t){if(!e)throw new Error(t)}function A(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function Z(e,t){t===void 0&&(t="/");let{pathname:n,search:a="",hash:r=""}=typeof e=="string"?E(e):e;return{pathname:n?n.startsWith("/")?n:I(n,t):t,search:ae(a),hash:re(r)}}function I(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function V(e,t,n){let a=typeof e=="string"?E(e):e,r=e===""||a.pathname===""?"/":a.pathname,u;if(r==null)u=n;else{let s=t.length-1;if(r.startsWith("..")){let f=r.split("/");for(;f[0]==="..";)f.shift(),s-=1;a.pathname=f.join("/")}u=s>=0?t[s]:"/"}let l=Z(a,u);return r&&r!=="/"&&r.endsWith("/")&&!l.pathname.endsWith("/")&&(l.pathname+="/"),l}function ee(e){return e===""||e.pathname===""?"/":typeof e=="string"?E(e).pathname:e.pathname}function te(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=e.charAt(t.length);return n&&n!=="/"?null:e.slice(t.length)||"/"}const D=e=>e.join("/").replace(/\/\/+/g,"/"),ne=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),ae=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,re=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function ce(e){O()||N(!1,"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:n}=c.useContext(S),{hash:a,pathname:r,search:u}=oe(e),l=r;if(t!=="/"){let s=ee(e),f=s!=null&&s.endsWith("/");l=r==="/"?t+(f?"/":""):D([t,r])}return n.createHref({pathname:l,search:u,hash:a})}function O(){return c.useContext(L)!=null}function K(){return O()||N(!1,"useLocation() may be used only in the context of a <Router> component."),c.useContext(L).location}function fe(){O()||N(!1,"useNavigate() may be used only in the context of a <Router> component.");let{basename:e,navigator:t}=c.useContext(S),{matches:n}=c.useContext($),{pathname:a}=K(),r=JSON.stringify(n.map(s=>s.pathnameBase)),u=c.useRef(!1);return c.useEffect(()=>{u.current=!0}),c.useCallback(function(s,f){if(f===void 0&&(f={}),A(u.current,"You should call navigate() in a React.useEffect(), not when your component is first rendered."),!u.current)return;if(typeof s=="number"){t.go(s);return}let d=V(s,JSON.parse(r),a);e!=="/"&&(d.pathname=D([e,d.pathname])),(f.replace?t.replace:t.push)(d,f.state)},[e,t,r,a])}function oe(e){let{matches:t}=c.useContext($),{pathname:n}=K(),a=JSON.stringify(t.map(r=>r.pathnameBase));return c.useMemo(()=>V(e,JSON.parse(a),n),[e,a,n])}function he(e){let{basename:t="/",children:n=null,location:a,navigationType:r=P.Pop,navigator:u,static:l=!1}=e;O()&&N(!1,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let s=ne(t),f=c.useMemo(()=>({basename:s,navigator:u,static:l}),[s,u,l]);typeof a=="string"&&(a=E(a));let{pathname:d="/",search:p="",hash:g="",state:x=null,key:m="default"}=a,w=c.useMemo(()=>{let R=te(d,s);return R==null?null:{pathname:R,search:p,hash:g,state:x,key:m}},[s,d,p,g,x,m]);return A(w!=null,'<Router basename="'+s+'"> is not able to match the URL '+('"'+d+p+g+'" because it does not start with the ')+"basename, so the <Router> won't render anything."),w==null?null:c.createElement(S.Provider,{value:f},c.createElement(L.Provider,{children:n,value:{location:w,navigationType:r}}))}export{he as R,K as a,oe as b,se as c,fe as d,X as e,ce as u};
