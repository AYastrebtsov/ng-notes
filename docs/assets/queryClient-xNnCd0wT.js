var X=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)};var i=(s,t,e)=>(X(s,t,"read from private field"),e?e.call(s):t.get(s)),o=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},n=(s,t,e,r)=>(X(s,t,"write to private field"),r?r.call(s,e):t.set(s,e),e);var V=(s,t,e,r)=>({set _(a){n(s,t,a,e)},get _(){return i(s,t,r)}}),P=(s,t,e)=>(X(s,t,"access private method"),e);import{R as pt,r as mt,n as b,t as gt,c as vt,a as y,s as B,i as Y,b as qt,S as dt,h as ft,m as st,M as bt,d as it,e as Ft,f as Ot,g as Pt,o as rt,j as Qt,k as at,p as nt}from"./QueryClientProvider-scR_tWxP.js";var H,T,m,f,c,_,K,F,Q,ht,At=(ht=class extends pt{constructor(t){super();o(this,F);o(this,H,void 0);o(this,T,void 0);o(this,m,void 0);o(this,f,void 0);o(this,c,void 0);o(this,_,void 0);o(this,K,void 0);n(this,K,!1),n(this,_,t.defaultOptions),this.setOptions(t.options),n(this,c,[]),n(this,m,t.cache),this.queryKey=t.queryKey,this.queryHash=t.queryHash,n(this,H,t.state||Ct(this.options)),this.state=i(this,H),this.scheduleGc()}get meta(){return this.options.meta}setOptions(t){this.options={...i(this,_),...t},this.updateGcTime(this.options.gcTime)}optionalRemove(){!i(this,c).length&&this.state.fetchStatus==="idle"&&i(this,m).remove(this)}setData(t,e){const r=mt(this.state.data,t,this.options);return P(this,F,Q).call(this,{data:r,type:"success",dataUpdatedAt:e==null?void 0:e.updatedAt,manual:e==null?void 0:e.manual}),r}setState(t,e){P(this,F,Q).call(this,{type:"setState",state:t,setStateOptions:e})}cancel(t){var r,a;const e=(r=i(this,f))==null?void 0:r.promise;return(a=i(this,f))==null||a.cancel(t),e?e.then(b).catch(b):Promise.resolve()}destroy(){super.destroy(),this.cancel({silent:!0})}reset(){this.destroy(),this.setState(i(this,H))}isActive(){return i(this,c).some(t=>t.options.enabled!==!1)}isDisabled(){return this.getObserversCount()>0&&!this.isActive()}isStale(){return this.state.isInvalidated?!0:this.getObserversCount()>0?i(this,c).some(t=>t.getCurrentResult().isStale):this.state.data===void 0}isStaleByTime(t=0){return this.state.isInvalidated||this.state.data===void 0||!gt(this.state.dataUpdatedAt,t)}onFocus(){var e;const t=i(this,c).find(r=>r.shouldFetchOnWindowFocus());t==null||t.refetch({cancelRefetch:!1}),(e=i(this,f))==null||e.continue()}onOnline(){var e;const t=i(this,c).find(r=>r.shouldFetchOnReconnect());t==null||t.refetch({cancelRefetch:!1}),(e=i(this,f))==null||e.continue()}addObserver(t){i(this,c).includes(t)||(i(this,c).push(t),this.clearGcTimeout(),i(this,m).notify({type:"observerAdded",query:this,observer:t}))}removeObserver(t){i(this,c).includes(t)&&(n(this,c,i(this,c).filter(e=>e!==t)),i(this,c).length||(i(this,f)&&(i(this,K)?i(this,f).cancel({revert:!0}):i(this,f).cancelRetry()),this.scheduleGc()),i(this,m).notify({type:"observerRemoved",query:this,observer:t}))}getObserversCount(){return i(this,c).length}invalidate(){this.state.isInvalidated||P(this,F,Q).call(this,{type:"invalidate"})}fetch(t,e){var U,W,z;if(this.state.fetchStatus!=="idle"){if(this.state.data!==void 0&&(e!=null&&e.cancelRefetch))this.cancel({silent:!0});else if(i(this,f))return i(this,f).continueRetry(),i(this,f).promise}if(t&&this.setOptions(t),!this.options.queryFn){const u=i(this,c).find(d=>d.options.queryFn);u&&this.setOptions(u.options)}Array.isArray(this.options.queryKey)||console.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");const r=new AbortController,a={queryKey:this.queryKey,meta:this.meta},l=u=>{Object.defineProperty(u,"signal",{enumerable:!0,get:()=>(n(this,K,!0),r.signal)})};l(a);const p=()=>(this.options.queryFn===B&&console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`),!this.options.queryFn||this.options.queryFn===B?Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`)):(n(this,K,!1),this.options.persister?this.options.persister(this.options.queryFn,a,this):this.options.queryFn(a))),v={fetchOptions:e,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:p};l(v),(U=this.options.behavior)==null||U.onFetch(v,this),n(this,T,this.state),(this.state.fetchStatus==="idle"||this.state.fetchMeta!==((W=v.fetchOptions)==null?void 0:W.meta))&&P(this,F,Q).call(this,{type:"fetch",meta:(z=v.fetchOptions)==null?void 0:z.meta});const L=u=>{var d,A,D,C;Y(u)&&u.silent||P(this,F,Q).call(this,{type:"error",error:u}),Y(u)||((A=(d=i(this,m).config).onError)==null||A.call(d,u,this),(C=(D=i(this,m).config).onSettled)==null||C.call(D,this.state.data,u,this)),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1};return n(this,f,vt({fn:v.fetchFn,abort:r.abort.bind(r),onSuccess:u=>{var d,A,D,C;if(u===void 0){console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`),L(new Error(`${this.queryHash} data is undefined`));return}this.setData(u),(A=(d=i(this,m).config).onSuccess)==null||A.call(d,u,this),(C=(D=i(this,m).config).onSettled)==null||C.call(D,u,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1},onError:L,onFail:(u,d)=>{P(this,F,Q).call(this,{type:"failed",failureCount:u,error:d})},onPause:()=>{P(this,F,Q).call(this,{type:"pause"})},onContinue:()=>{P(this,F,Q).call(this,{type:"continue"})},retry:v.options.retry,retryDelay:v.options.retryDelay,networkMode:v.options.networkMode})),i(this,f).promise}},H=new WeakMap,T=new WeakMap,m=new WeakMap,f=new WeakMap,c=new WeakMap,_=new WeakMap,K=new WeakMap,F=new WeakSet,Q=function(t){const e=r=>{switch(t.type){case"failed":return{...r,fetchFailureCount:t.failureCount,fetchFailureReason:t.error};case"pause":return{...r,fetchStatus:"paused"};case"continue":return{...r,fetchStatus:"fetching"};case"fetch":return{...r,...Dt(r.data,this.options),fetchMeta:t.meta??null};case"success":return{...r,data:t.data,dataUpdateCount:r.dataUpdateCount+1,dataUpdatedAt:t.dataUpdatedAt??Date.now(),error:null,isInvalidated:!1,status:"success",...!t.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};case"error":const a=t.error;return Y(a)&&a.revert&&i(this,T)?{...i(this,T),fetchStatus:"idle"}:{...r,error:a,errorUpdateCount:r.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:r.fetchFailureCount+1,fetchFailureReason:a,fetchStatus:"idle",status:"error"};case"invalidate":return{...r,isInvalidated:!0};case"setState":return{...r,...t.state}}};this.state=e(this.state),y.batch(()=>{i(this,c).forEach(r=>{r.onQueryUpdate()}),i(this,m).notify({query:this,type:"updated",action:t})})},ht);function Dt(s,t){return{fetchFailureCount:0,fetchFailureReason:null,fetchStatus:qt(t.networkMode)?"fetching":"paused",...s===void 0&&{error:null,status:"pending"}}}function Ct(s){const t=typeof s.initialData=="function"?s.initialData():s.initialData,e=t!==void 0,r=e?typeof s.initialDataUpdatedAt=="function"?s.initialDataUpdatedAt():s.initialDataUpdatedAt:0;return{data:t,dataUpdateCount:0,dataUpdatedAt:e?r??Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:e?"success":"pending",fetchStatus:"idle"}}var O,ot,St=(ot=class extends dt{constructor(t={}){super();o(this,O,void 0);this.config=t,n(this,O,new Map)}build(t,e,r){const a=e.queryKey,l=e.queryHash??ft(a,e);let p=this.get(l);return p||(p=new At({cache:this,queryKey:a,queryHash:l,options:t.defaultQueryOptions(e),state:r,defaultOptions:t.getQueryDefaults(a)}),this.add(p)),p}add(t){i(this,O).has(t.queryHash)||(i(this,O).set(t.queryHash,t),this.notify({type:"added",query:t}))}remove(t){const e=i(this,O).get(t.queryHash);e&&(t.destroy(),e===t&&i(this,O).delete(t.queryHash),this.notify({type:"removed",query:t}))}clear(){y.batch(()=>{this.getAll().forEach(t=>{this.remove(t)})})}get(t){return i(this,O).get(t)}getAll(){return[...i(this,O).values()]}find(t){const e={exact:!0,...t};return this.getAll().find(r=>st(e,r))}findAll(t={}){const e=this.getAll();return Object.keys(t).length>0?e.filter(r=>st(t,r)):e}notify(t){y.batch(()=>{this.listeners.forEach(e=>{e(t)})})}onFocus(){y.batch(()=>{this.getAll().forEach(t=>{t.onFocus()})})}onOnline(){y.batch(()=>{this.getAll().forEach(t=>{t.onOnline()})})}},O=new WeakMap,ot),g,N,R,ct,wt=(ct=class extends dt{constructor(t={}){super();o(this,g,void 0);o(this,N,void 0);o(this,R,void 0);this.config=t,n(this,g,[]),n(this,N,0)}build(t,e,r){const a=new bt({mutationCache:this,mutationId:++V(this,N)._,options:t.defaultMutationOptions(e),state:r});return this.add(a),a}add(t){i(this,g).push(t),this.notify({type:"added",mutation:t})}remove(t){n(this,g,i(this,g).filter(e=>e!==t)),this.notify({type:"removed",mutation:t})}clear(){y.batch(()=>{i(this,g).forEach(t=>{this.remove(t)})})}getAll(){return i(this,g)}find(t){const e={exact:!0,...t};return i(this,g).find(r=>it(e,r))}findAll(t={}){return i(this,g).filter(e=>it(t,e))}notify(t){y.batch(()=>{this.listeners.forEach(e=>{e(t)})})}resumePausedMutations(){return n(this,R,(i(this,R)??Promise.resolve()).then(()=>{const t=i(this,g).filter(e=>e.state.isPaused);return y.batch(()=>t.reduce((e,r)=>e.then(()=>r.continue().catch(b)),Promise.resolve()))}).then(()=>{n(this,R,void 0)})),i(this,R)}},g=new WeakMap,N=new WeakMap,R=new WeakMap,ct);function Mt(s){return{onFetch:(t,e)=>{const r=async()=>{var A,D,C,Z,x;const a=t.options,l=(C=(D=(A=t.fetchOptions)==null?void 0:A.meta)==null?void 0:D.fetchMore)==null?void 0:C.direction,p=((Z=t.state.data)==null?void 0:Z.pages)||[],v=((x=t.state.data)==null?void 0:x.pageParams)||[],L={pages:[],pageParams:[]};let U=!1;const W=q=>{Object.defineProperty(q,"signal",{enumerable:!0,get:()=>(t.signal.aborted?U=!0:t.signal.addEventListener("abort",()=>{U=!0}),t.signal)})},z=t.options.queryFn&&t.options.queryFn!==B?t.options.queryFn:()=>(t.options.queryFn===B&&console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.options.queryHash}'`),Promise.reject(new Error(`Missing queryFn: '${t.options.queryHash}'`))),u=async(q,S,E)=>{if(U)return Promise.reject();if(S==null&&q.pages.length)return Promise.resolve(q);const J={queryKey:t.queryKey,pageParam:S,direction:E?"backward":"forward",meta:t.options.meta};W(J);const yt=await z(J),{maxPages:tt}=t.options,et=E?Ft:Ot;return{pages:et(q.pages,yt,tt),pageParams:et(q.pageParams,S,tt)}};let d;if(l&&p.length){const q=l==="backward",S=q?kt:ut,E={pages:p,pageParams:v},J=S(a,E);d=await u(E,J,q)}else{d=await u(L,v[0]??a.initialPageParam);const q=s??p.length;for(let S=1;S<q;S++){const E=ut(a,d);d=await u(d,E)}}return d};t.options.persister?t.fetchFn=()=>{var a,l;return(l=(a=t.options).persister)==null?void 0:l.call(a,r,{queryKey:t.queryKey,meta:t.options.meta,signal:t.signal},e)}:t.fetchFn=r}}}function ut(s,{pages:t,pageParams:e}){const r=t.length-1;return s.getNextPageParam(t[r],t,e[r],e)}function kt(s,{pages:t,pageParams:e}){var r;return(r=s.getPreviousPageParam)==null?void 0:r.call(s,t[0],t,e[0],e)}var h,w,M,I,j,k,G,$,lt,Rt=(lt=class{constructor(s={}){o(this,h,void 0);o(this,w,void 0);o(this,M,void 0);o(this,I,void 0);o(this,j,void 0);o(this,k,void 0);o(this,G,void 0);o(this,$,void 0);n(this,h,s.queryCache||new St),n(this,w,s.mutationCache||new wt),n(this,M,s.defaultOptions||{}),n(this,I,new Map),n(this,j,new Map),n(this,k,0)}mount(){V(this,k)._++,i(this,k)===1&&(n(this,G,Pt.subscribe(async s=>{s&&(await this.resumePausedMutations(),i(this,h).onFocus())})),n(this,$,rt.subscribe(async s=>{s&&(await this.resumePausedMutations(),i(this,h).onOnline())})))}unmount(){var s,t;V(this,k)._--,i(this,k)===0&&((s=i(this,G))==null||s.call(this),n(this,G,void 0),(t=i(this,$))==null||t.call(this),n(this,$,void 0))}isFetching(s){return i(this,h).findAll({...s,fetchStatus:"fetching"}).length}isMutating(s){return i(this,w).findAll({...s,status:"pending"}).length}getQueryData(s){var e;const t=this.defaultQueryOptions({queryKey:s});return(e=i(this,h).get(t.queryHash))==null?void 0:e.state.data}ensureQueryData(s){const t=this.getQueryData(s.queryKey);if(t===void 0)return this.fetchQuery(s);{const e=this.defaultQueryOptions(s),r=i(this,h).build(this,e);return s.revalidateIfStale&&r.isStaleByTime(e.staleTime)&&this.prefetchQuery(e),Promise.resolve(t)}}getQueriesData(s){return i(this,h).findAll(s).map(({queryKey:t,state:e})=>{const r=e.data;return[t,r]})}setQueryData(s,t,e){const r=this.defaultQueryOptions({queryKey:s}),a=i(this,h).get(r.queryHash),l=a==null?void 0:a.state.data,p=Qt(t,l);if(p!==void 0)return i(this,h).build(this,r).setData(p,{...e,manual:!0})}setQueriesData(s,t,e){return y.batch(()=>i(this,h).findAll(s).map(({queryKey:r})=>[r,this.setQueryData(r,t,e)]))}getQueryState(s){var e;const t=this.defaultQueryOptions({queryKey:s});return(e=i(this,h).get(t.queryHash))==null?void 0:e.state}removeQueries(s){const t=i(this,h);y.batch(()=>{t.findAll(s).forEach(e=>{t.remove(e)})})}resetQueries(s,t){const e=i(this,h),r={type:"active",...s};return y.batch(()=>(e.findAll(s).forEach(a=>{a.reset()}),this.refetchQueries(r,t)))}cancelQueries(s={},t={}){const e={revert:!0,...t},r=y.batch(()=>i(this,h).findAll(s).map(a=>a.cancel(e)));return Promise.all(r).then(b).catch(b)}invalidateQueries(s={},t={}){return y.batch(()=>{if(i(this,h).findAll(s).forEach(r=>{r.invalidate()}),s.refetchType==="none")return Promise.resolve();const e={...s,type:s.refetchType??s.type??"active"};return this.refetchQueries(e,t)})}refetchQueries(s={},t){const e={...t,cancelRefetch:(t==null?void 0:t.cancelRefetch)??!0},r=y.batch(()=>i(this,h).findAll(s).filter(a=>!a.isDisabled()).map(a=>{let l=a.fetch(void 0,e);return e.throwOnError||(l=l.catch(b)),a.state.fetchStatus==="paused"?Promise.resolve():l}));return Promise.all(r).then(b)}fetchQuery(s){const t=this.defaultQueryOptions(s);t.retry===void 0&&(t.retry=!1);const e=i(this,h).build(this,t);return e.isStaleByTime(t.staleTime)?e.fetch(t):Promise.resolve(e.state.data)}prefetchQuery(s){return this.fetchQuery(s).then(b).catch(b)}fetchInfiniteQuery(s){return s.behavior=Mt(s.pages),this.fetchQuery(s)}prefetchInfiniteQuery(s){return this.fetchInfiniteQuery(s).then(b).catch(b)}resumePausedMutations(){return rt.isOnline()?i(this,w).resumePausedMutations():Promise.resolve()}getQueryCache(){return i(this,h)}getMutationCache(){return i(this,w)}getDefaultOptions(){return i(this,M)}setDefaultOptions(s){n(this,M,s)}setQueryDefaults(s,t){i(this,I).set(at(s),{queryKey:s,defaultOptions:t})}getQueryDefaults(s){const t=[...i(this,I).values()];let e={};return t.forEach(r=>{nt(s,r.queryKey)&&(e={...e,...r.defaultOptions})}),e}setMutationDefaults(s,t){i(this,j).set(at(s),{mutationKey:s,defaultOptions:t})}getMutationDefaults(s){const t=[...i(this,j).values()];let e={};return t.forEach(r=>{nt(s,r.mutationKey)&&(e={...e,...r.defaultOptions})}),e}defaultQueryOptions(s){if(s._defaulted)return s;const t={...i(this,M).queries,...this.getQueryDefaults(s.queryKey),...s,_defaulted:!0};return t.queryHash||(t.queryHash=ft(t.queryKey,t)),t.refetchOnReconnect===void 0&&(t.refetchOnReconnect=t.networkMode!=="always"),t.throwOnError===void 0&&(t.throwOnError=!!t.suspense),!t.networkMode&&t.persister&&(t.networkMode="offlineFirst"),t.enabled!==!0&&t.queryFn===B&&(t.enabled=!1),t}defaultMutationOptions(s){return s!=null&&s._defaulted?s:{...i(this,M).mutations,...(s==null?void 0:s.mutationKey)&&this.getMutationDefaults(s.mutationKey),...s,_defaulted:!0}}clear(){i(this,h).clear(),i(this,w).clear()}},h=new WeakMap,w=new WeakMap,M=new WeakMap,I=new WeakMap,j=new WeakMap,k=new WeakMap,G=new WeakMap,$=new WeakMap,lt);export{Rt as Q,Dt as f};
