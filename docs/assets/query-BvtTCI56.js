var D=(a,t,e)=>{if(!t.has(a))throw TypeError("Cannot "+e)};var s=(a,t,e)=>(D(a,t,"read from private field"),e?e.call(a):t.get(a)),f=(a,t,e)=>{if(t.has(a))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(a):t.set(a,e)},c=(a,t,e,i)=>(D(a,t,"write to private field"),i?i.call(a,e):t.set(a,e),e);var p=(a,t,e)=>(D(a,t,"access private method"),e);import{R as E,r as G,n as K,t as H,c as P,a as Q,s as M,i as b,b as x}from"./QueryClientProvider-DLasFzzO.js";var F,g,o,h,n,C,v,l,y,I,z=(I=class extends E{constructor(t){super();f(this,l);f(this,F,void 0);f(this,g,void 0);f(this,o,void 0);f(this,h,void 0);f(this,n,void 0);f(this,C,void 0);f(this,v,void 0);c(this,v,!1),c(this,C,t.defaultOptions),this.setOptions(t.options),c(this,n,[]),c(this,o,t.cache),this.queryKey=t.queryKey,this.queryHash=t.queryHash,c(this,F,t.state||j(this.options)),this.state=s(this,F),this.scheduleGc()}get meta(){return this.options.meta}setOptions(t){this.options={...s(this,C),...t},this.updateGcTime(this.options.gcTime)}optionalRemove(){!s(this,n).length&&this.state.fetchStatus==="idle"&&s(this,o).remove(this)}setData(t,e){const i=G(this.state.data,t,this.options);return p(this,l,y).call(this,{data:i,type:"success",dataUpdatedAt:e==null?void 0:e.updatedAt,manual:e==null?void 0:e.manual}),i}setState(t,e){p(this,l,y).call(this,{type:"setState",state:t,setStateOptions:e})}cancel(t){var i,u;const e=(i=s(this,h))==null?void 0:i.promise;return(u=s(this,h))==null||u.cancel(t),e?e.then(K).catch(K):Promise.resolve()}destroy(){super.destroy(),this.cancel({silent:!0})}reset(){this.destroy(),this.setState(s(this,F))}isActive(){return s(this,n).some(t=>t.options.enabled!==!1)}isDisabled(){return this.getObserversCount()>0&&!this.isActive()}isStale(){return this.state.isInvalidated?!0:this.getObserversCount()>0?s(this,n).some(t=>t.getCurrentResult().isStale):this.state.data===void 0}isStaleByTime(t=0){return this.state.isInvalidated||this.state.data===void 0||!H(this.state.dataUpdatedAt,t)}onFocus(){var e;const t=s(this,n).find(i=>i.shouldFetchOnWindowFocus());t==null||t.refetch({cancelRefetch:!1}),(e=s(this,h))==null||e.continue()}onOnline(){var e;const t=s(this,n).find(i=>i.shouldFetchOnReconnect());t==null||t.refetch({cancelRefetch:!1}),(e=s(this,h))==null||e.continue()}addObserver(t){s(this,n).includes(t)||(s(this,n).push(t),this.clearGcTimeout(),s(this,o).notify({type:"observerAdded",query:this,observer:t}))}removeObserver(t){s(this,n).includes(t)&&(c(this,n,s(this,n).filter(e=>e!==t)),s(this,n).length||(s(this,h)&&(s(this,v)?s(this,h).cancel({revert:!0}):s(this,h).cancelRetry()),this.scheduleGc()),s(this,o).notify({type:"observerRemoved",query:this,observer:t}))}getObserversCount(){return s(this,n).length}invalidate(){this.state.isInvalidated||p(this,l,y).call(this,{type:"invalidate"})}fetch(t,e){var O,k,w;if(this.state.fetchStatus!=="idle"){if(this.state.data!==void 0&&(e!=null&&e.cancelRefetch))this.cancel({silent:!0});else if(s(this,h))return s(this,h).continueRetry(),s(this,h).promise}if(t&&this.setOptions(t),!this.options.queryFn){const r=s(this,n).find(d=>d.options.queryFn);r&&this.setOptions(r.options)}Array.isArray(this.options.queryKey)||console.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");const i=new AbortController,u={queryKey:this.queryKey,meta:this.meta},U=r=>{Object.defineProperty(r,"signal",{enumerable:!0,get:()=>(c(this,v,!0),i.signal)})};U(u);const T=()=>(this.options.queryFn===M&&console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`),!this.options.queryFn||this.options.queryFn===M?Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`)):(c(this,v,!1),this.options.persister?this.options.persister(this.options.queryFn,u,this):this.options.queryFn(u))),m={fetchOptions:e,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:T};U(m),(O=this.options.behavior)==null||O.onFetch(m,this),c(this,g,this.state),(this.state.fetchStatus==="idle"||this.state.fetchMeta!==((k=m.fetchOptions)==null?void 0:k.meta))&&p(this,l,y).call(this,{type:"fetch",meta:(w=m.fetchOptions)==null?void 0:w.meta});const R=r=>{var d,q,S,A;b(r)&&r.silent||p(this,l,y).call(this,{type:"error",error:r}),b(r)||((q=(d=s(this,o).config).onError)==null||q.call(d,r,this),(A=(S=s(this,o).config).onSettled)==null||A.call(S,this.state.data,r,this)),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1};return c(this,h,P({fn:m.fetchFn,abort:i.abort.bind(i),onSuccess:r=>{var d,q,S,A;if(r===void 0){console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`),R(new Error(`${this.queryHash} data is undefined`));return}this.setData(r),(q=(d=s(this,o).config).onSuccess)==null||q.call(d,r,this),(A=(S=s(this,o).config).onSettled)==null||A.call(S,r,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1},onError:R,onFail:(r,d)=>{p(this,l,y).call(this,{type:"failed",failureCount:r,error:d})},onPause:()=>{p(this,l,y).call(this,{type:"pause"})},onContinue:()=>{p(this,l,y).call(this,{type:"continue"})},retry:m.options.retry,retryDelay:m.options.retryDelay,networkMode:m.options.networkMode})),s(this,h).promise}},F=new WeakMap,g=new WeakMap,o=new WeakMap,h=new WeakMap,n=new WeakMap,C=new WeakMap,v=new WeakMap,l=new WeakSet,y=function(t){const e=i=>{switch(t.type){case"failed":return{...i,fetchFailureCount:t.failureCount,fetchFailureReason:t.error};case"pause":return{...i,fetchStatus:"paused"};case"continue":return{...i,fetchStatus:"fetching"};case"fetch":return{...i,...$(i.data,this.options),fetchMeta:t.meta??null};case"success":return{...i,data:t.data,dataUpdateCount:i.dataUpdateCount+1,dataUpdatedAt:t.dataUpdatedAt??Date.now(),error:null,isInvalidated:!1,status:"success",...!t.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};case"error":const u=t.error;return b(u)&&u.revert&&s(this,g)?{...s(this,g),fetchStatus:"idle"}:{...i,error:u,errorUpdateCount:i.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:i.fetchFailureCount+1,fetchFailureReason:u,fetchStatus:"idle",status:"error"};case"invalidate":return{...i,isInvalidated:!0};case"setState":return{...i,...t.state}}};this.state=e(this.state),Q.batch(()=>{s(this,n).forEach(i=>{i.onQueryUpdate()}),s(this,o).notify({query:this,type:"updated",action:t})})},I);function $(a,t){return{fetchFailureCount:0,fetchFailureReason:null,fetchStatus:x(t.networkMode)?"fetching":"paused",...a===void 0&&{error:null,status:"pending"}}}function j(a){const t=typeof a.initialData=="function"?a.initialData():a.initialData,e=t!==void 0,i=e?typeof a.initialDataUpdatedAt=="function"?a.initialDataUpdatedAt():a.initialDataUpdatedAt:0;return{data:t,dataUpdateCount:0,dataUpdatedAt:e?i??Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:e?"success":"pending",fetchStatus:"idle"}}export{z as Q,$ as f};
